from src.crypto import sign
from src.ledger import Ledger
from src.safety import Safety
from src.block import QC, Block, BlockTree
from src.mempool import MemPool
from src.info import ValidatorInfo
from src.pacemaker import Pacemaker
from src.messages import TC, ProposalMsg
from src.leader_election import LeaderElection


class Validator(process):
    def setup(author, priv_key, validator_pub, client_pub, validators, rtt):
        #self.broadcast = servers
        self.validator_info = ValidatorInfo(
            author=author,
            validator_pks=validator_pub,
            private_key=priv_key,
            client_pks=client_pub,
            f=(len(validator_pub) - 1)//3
        )
        n_validators = len(self.validator_info.validator_pks)
        self.ledger = Ledger(ledger_file_name=f'ledgers/ledger-{self.validator_info.author}.log',
        n_validators=n_validators)
        self.mempool = MemPool()
        self.block_tree = BlockTree(ledger, validator_info)
        output("HERE")
        self.safety = Safety(ledger, block_tree, validator_info)
        self.leader_election = LeaderElection(len(validator_pub))
        self.pacemaker = Pacemaker()
        self.validators = validators
        self.rtt = rtt

    def process_certificate_qc(qc):
        # output("before processing QC", qc)
        block_tree.process_qc(qc)
        output("process_qc done")
        leader_election.update_leaders(qc)
        output("update leaders done")
        pacemaker.advance_round_qc(qc)
        output("advance round qc done")
    
    def process_proposal_msg(proposal_msg):
        output("1")
        process_certificate_qc(proposal_msg.block.qc)
        output("2")
        process_certificate_qc(proposal_msg.high_commit_qc)
        output("3")
        pacemaker.advance_round_tc(proposal_msg.last_round_tc)
        round = pacemaker.current_round
        output("4")
        leader = leader_election.get_leader(round)
        output("5")
        if proposal_msg.block.round != round or proposal_msg.sender != leader or proposal_msg.block.author != leader:
            return
        self.block_tree.execute_and_insert(proposal_msg)
        vote_msg = safety.make_vote(proposal_msg.block,proposal_msg.last_round_tc)
        if vote_msg is not None:
            send(vote_msg.to_tuple(), to=leader_election.LeaderElection.get_leader(round+1))
    
    def process_timeout_msg(timeout_msg):
        process_certificate_qc(timeout_msg.tmo_info.high_qc)
        process_certificate_qc(timeout_msg.high_commit_qc)
        pacemaker.advance_round_tc(timeout_msg.last_round_tc)
        tc = pacemaker.process_remote_timeout(timeout_msg)
        if tc != None:
            pacemaker.advance_round_tc(tc)
            process_new_round_event(tc)
    
    def process_vote_msg(vote_msg):
        qc = block_tree.process_vote(vote_msg)
        if qc is not None:
            process_certificate_qc(qc)
            process_new_round_event(None)
    
    def process_new_round_event(last_tc):
        leader = leader_election.get_leader(pacemaker.current_round)
        output("Leader of this round is:", leader)
        # print(self.mempool.dq)
        if leader == author:
            txns = self.mempool.get_transactions()
            # txns = '123'
            output("txns", txns)
            block = block_tree.generate_block(txns, pacemaker.current_round)
            output("block", block.block_id)
            proposal_msg = ProposalMsg(block, last_tc, block_tree.high_commit_qc, 
            '', '')
            send(ProposalMsg.to_tuple(proposal_msg), to=validators)

    def run():
        # await(1 == 0)
        # while(1):
        # process never stops
        if author == 0:
            if await(some(received(('Propose', _, _, _)))):
                process_new_round_event(None)
        
        if await(len(setof(c, received(('Done'), from_=c))) >= len(client_pub)):
            reset(received)

    def receive(msg=('LocalTimeout')):
        raise NotImplementedError
        # pacemaker.local_timeout_round()

    def receive(msg=('ProposalMsg', block, tc, high_commit_qc, signature, sender)):
        output("Received ProposalMsg")
        block = Block.from_tuple(*block)
        # output("Block DONE")
        tc = None if not tc else TC(*tc)
        # output("tc DONE")
        # output("HIGH COMMIT QC", high_commit_qc)
        high_commit_qc = QC.from_tuple(*high_commit_qc)
        proposal_msg = ProposalMsg(block, tc, high_commit_qc, signature, sender)
        output("Formatted / validated. Processing ProposalMsg")
        process_proposal_msg(proposal_msg)

    def receive(msg=('VoteMsg', _, _, _, _, _)):
        process_vote_msg(msg)

    def receive(msg=('TimeoutMsg')):
        # process_timeout_message(msg)
        raise NotImplementedError

    def receive(msg=('Propose', round_no, id, message_content)):
        self.mempool.try_to_add_to_mempool(('Propose', round_no, id, message_content))
        output("handling message in receive queue")
        output("Received message for round ", round_no, "from client ", id,  "message content is ", message_content)
        # self.mempool.commit_to_cache(round_no, id, 'Comitted ' + str(round_no) + ' - ' + str(id))
        # send(('Comitted', round_no, 'Comitted ' + str(round_no) + ' - ' + str(id)), to=c)
